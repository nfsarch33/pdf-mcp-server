# Integration Guide: Standards into Pepper Memory Bank

**Date**: 2025-12-16  
**Purpose**: Copy standards from `coding-standards-v9-1.md` into Pepper Memory Bank for daily use in Cursor  

---

## Quick Integration (5 minutes)

### Step 1: Add to Pepper Memory Bank

```bash
# Copy the main standards file
cp ~/Downloads/coding-standards-v9-1.md ~/memo/global-memories/

# OR manually create the file
cat > ~/memo/global-memories/coding-standards-v9-1.md << 'EOF'
# [Paste full content from coding-standards-v9-1.md]
EOF

# Commit to git
cd ~/memo
git add coding-standards-v9-1.md
git commit -m "add: coding standards for Python, Go, MCP, AI (v9.1)"
```

### Step 2: Reference in .cursor/rules

Add to your workspace `.cursor/rules`:

```yaml
# CODING STANDARDS REFERENCE

## For Python Development
Read: memory_bank_read("global-memories", "coding-standards-v9-1.md")
Pattern: Use uv for packages, conda for system deps (hybrid approach)
Pattern: Type hints required on public APIs
Pattern: Error handling with custom exceptions, use logger not print()

## For Go Development
Pattern: Always check err != nil and wrap with context
Pattern: Pass context.Context as first parameter
Pattern: Use table-driven tests
Pattern: Define interfaces at consumer, not provider

## For MCP Servers
Pattern: Stateless prompts (no side-effects), actions → tools
Pattern: Validate all inputs with JSON Schema
Pattern: Semantic versioning, canary deployments
Pattern: Monitor with OpenTelemetry (latency, errors)

## For AI/LLM Context
Pattern: 3-layer context (instructional, knowledge, tool)
Pattern: Quality gates before memorizing (needed every conversation?)
Pattern: Estimate tokens before sending (track context window)

## For API/Microservices
Pattern: Design-first with OpenAPI spec
Pattern: All endpoints need X-Request-ID for tracing
Pattern: Retry with exponential backoff + circuit breaker
Pattern: Structured errors with codes + messages

## For Academic Research
Pattern: Log hyperparameters + results in JSON
Pattern: Commit uv.lock + fix random seeds
Pattern: Version datasets separately (Zenodo DOI)
Pattern: Figures must be generated by code, not manual
```

### Step 3: Create Quick Reference Cards

Create separate memory files for your current project:

```bash
# Python project
cat > ~/memo/global-memories/python-checklist.md << 'EOF'
# Python Quality Gates

- [ ] uv sync creates reproducible env
- [ ] Type hints on all public functions
- [ ] Docstrings (module, class, function)
- [ ] ruff check && mypy passing
- [ ] pytest >= 80% coverage
- [ ] No print() → use logger
- [ ] No hardcoded secrets
EOF

# Go project
cat > ~/memo/global-memories/go-checklist.md << 'EOF'
# Go Quality Gates

- [ ] go fmt applied
- [ ] go vet passing
- [ ] Errors wrapped with context
- [ ] Context passed to goroutines
- [ ] golangci-lint clean
- [ ] Table-driven tests written
EOF

# MCP server
cat > ~/memo/global-memories/mcp-checklist.md << 'EOF'
# MCP Server Checklist

- [ ] JSON Schema validation on all args
- [ ] Version number incremented
- [ ] Canary deployment < 10% traffic
- [ ] SLO metrics monitored (p95, error rate)
- [ ] RBAC scopes enforced
- [ ] OpenTelemetry traces enabled
EOF

git -C ~/memo add -A && git commit -m "add: quick reference checklists"
```

---

## Integration Patterns (Choose One)

### Pattern 1: Inline Rules (Minimal)

Add critical rules directly to `.cursor/rules`:

```yaml
# PYTHON STANDARDS
Remember:
- Use uv for packages (10-100x faster than pip)
- Type hints on all public APIs
- Error handling: custom exceptions + logger
- Commit uv.lock for reproducibility

# GO STANDARDS
Remember:
- ALWAYS wrap errors: fmt.Errorf("operation: %w", err)
- Pass context.Context as first parameter
- Define interfaces at consumer
```

### Pattern 2: Hybrid (Recommended)

Keep detailed standards in Pepper, reference in rules:

```yaml
# .cursor/rules
CODING STANDARDS:
Read from memory: memory_bank_read("global-memories", "coding-standards-v9-1.md")

Key patterns:
- Python: uv for packages, type hints required, custom exceptions
- Go: error wrapping, context always, interfaces at consumer
- MCP: stateless prompts, JSON Schema validation, semantic versioning
- Academic: log hyperparameters, fix seeds, version datasets

For details: Ask "show me Python type hints example" or "Go error handling pattern"
```

### Pattern 3: Project-Specific (Full)

Create project-specific standards files:

```bash
# Create a project-specific standards file
cat > ~/memo/global-memories/project-{name}-standards.md << 'EOF'
# Project: {name} Standards

## Stack
- Python 3.11 + uv
- PostgreSQL
- FastAPI
- Docker Kubernetes

## Quality Gates (Project Specific)
- [ ] Lint: ruff check + mypy
- [ ] Tests: pytest with coverage >= 85%
- [ ] Database: migrations versioned
- [ ] API: OpenAPI spec matches code
- [ ] Logging: structured JSON logs with request_id

## Environment
- Local: uv sync && uv run pytest
- CI: GitHub Actions (lint, test, type check)
- Deploy: Docker → ECR → ECS

## Key Files
- pyproject.toml (dependencies)
- Dockerfile (production image)
- docker-compose.yml (local dev)
EOF

git -C ~/memo add -A && git commit -m "add: project-{name}-standards"
```

---

## Daily Usage Examples

### When Starting a Python Project

```
User in Cursor: "I'm starting a new Python project for data processing"

Cursor should:
1. memory_bank_read("global-memories", "coding-standards-v9-1.md")
2. Retrieve Python section (uv/conda, project structure, type hints)
3. Suggest:
   - Run: uv init myproject
   - Structure: src/projectname, tests/, docs/
   - Add: type hints, docstrings, pytest
   - Commit: pyproject.toml, uv.lock, .gitignore
```

### When Starting a Go Microservice

```
User: "Building a Go API gateway with context timeouts"

Cursor should:
1. memory_bank_read("global-memories", "coding-standards-v9-1.md")
2. Retrieve Go section (context usage, error wrapping, interfaces)
3. Suggest pattern:
   ```go
   func Fetch(ctx context.Context, id string) (Data, error) {
       // Check context first
       select {
       case <-ctx.Done():
           return nil, fmt.Errorf("fetch: %w", ctx.Err())
       default:
       }
       
       // ... implementation with wrapped errors
   }
   ```
4. Recommend: errgroup for concurrent ops, circuit breaker for failover
```

### When Writing an Academic Paper

```
User: "I need to make my ML training reproducible for a conference paper"

Cursor should:
1. memory_bank_read("global-memories", "coding-standards-v9-1.md")
2. Retrieve Academic Research section
3. Suggest checklist:
   - [ ] Fix random seeds: np.random.seed(42)
   - [ ] Log hyperparams to results/config.json
   - [ ] Commit uv.lock (exact dependency versions)
   - [ ] Version dataset: git-lfs or Zenodo DOI
   - [ ] Create reproduce.py script
   - [ ] Document in README: "uv sync && uv run python reproduce.py"
```

### When Building an MCP Server

```
User: "I'm creating an MCP server for code analysis"

Cursor should:
1. memory_bank_read("global-memories", "coding-standards-v9-1.md")
2. Retrieve MCP section
3. Suggest:
   - Prompt versioning (1.0.0, 1.1.0, 2.0.0)
   - JSON Schema validation for all arguments
   - Canary deployment (90% stable, 10% canary)
   - OpenTelemetry for latency/errors
   - Security: OAuth 2.1 + RBAC scopes
```

---

## Maintenance

### Monthly Review

```bash
# Check if standards are being followed
git -C ~/memo log --oneline | head -10

# Update if needed (new Python versions, Go updates, etc.)
# Example: uv now supports X, add to standards
git -C ~/memo add coding-standards-v9-1.md
git -C ~/memo commit -m "update: uv 0.x.x new features"
```

### Quarterly Refresh

```bash
# Archive old standards
mv ~/memo/global-memories/coding-standards-v9-0.md \
   ~/Code/global-kb/archive/coding-standards-v9-0-2025Q4.md

git -C ~/memo add -A
git -C ~/memo commit -m "archive: old standards v9.0"

# Update version number in latest file
sed -i 's/Version.*9.0/Version 9.1/' \
    ~/memo/global-memories/coding-standards-v9-1.md
```

---

## Next Steps

1. **Immediate** (Today):
   - [ ] Copy `coding-standards-v9-1.md` to `~/memo/global-memories/`
   - [ ] Commit to git: `git -C ~/memo commit -am "add: coding standards v9.1"`
   - [ ] Update `.cursor/rules` with reference

2. **This Week**:
   - [ ] Create project-specific standards (Python, Go, or MCP)
   - [ ] Run checklist on current project
   - [ ] Note any gaps or missing patterns

3. **This Month**:
   - [ ] Test with Cursor on real tasks
   - [ ] Refine patterns based on experience
   - [ ] Document team-specific standards

4. **Ongoing**:
   - [ ] Monthly git log review
   - [ ] Quarterly version updates
   - [ ] Archive old versions to global-kb/

---

**These standards are living documents.** Update as new tools, languages, and frameworks evolve.
